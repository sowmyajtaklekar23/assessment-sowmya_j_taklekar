{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  matchLeftIncl,\n  matchRightIncl,\n  matchLeft,\n  matchRight,\n&#x7D; from \"string-match-left-right\";\n\n// 3rd character is \"d\" because indexes start from zero.\n// We're checking the string to the left of it, \"bcd\", inclusive of current character (\"d\").\n// This means, \"bcd\" has to end with existing character and the other chars to the left\n// must match exactly:\nassert.equal(matchLeftIncl(\"abcdefghi\", 3, [\"bcd\"]), \"bcd\");\n\n// neither \"ab\" nor \"zz\" are to the left of 3rd index, \"d\":\nassert.equal(matchLeft(\"abcdefghi\", 3, [\"ab\", `zz`]), false);\n\n// \"def\" is to the right of 3rd index (including it), \"d\":\nassert.equal(matchRightIncl(\"abcdefghi\", 3, [\"def\", `zzz`]), \"def\");\n\n// One of values, \"ef\" is exactly to the right of 3rd index, \"d\":\nassert.equal(matchRight(\"abcdefghi\", 3, [\"ef\", `zz`]), \"ef\");"},"cb.js":{"title":"The Callback Use","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  matchLeftIncl,\n  matchRightIncl,\n  matchLeft,\n  matchRight,\n&#x7D; from \"string-match-left-right\";\n\n// imagine you looped the string and wanted to catch where does attribute \"class\" start\n// and end (not to mention to ensure that it's a real attribute, not something ending with this\n// string \"class\").\n// You catch \"=\", an index number 8.\n// This library can check, is \"class\" to the left of it and feed what's to the left of it\n// to your supplied callback function, which happens to be a checker \"is it a space\":\nfunction isSpace(char) &#x7B;\n  return typeof char === \"string\" && char.trim() === \"\";\n&#x7D;\n\nassert.equal(\n  matchLeft('<a class=\"something\">', 8, \"class\", &#x7B; cb: isSpace &#x7D;),\n  \"class\"\n);"}}